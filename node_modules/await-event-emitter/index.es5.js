'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var isPromise = _interopDefault(require('is-promise'));

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var nodeAwaitEventEmitter = createCommonjsModule(function (module) {
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var emit = function () {
  var _ref3 = _asyncToGenerator(function* (type) {
    var _this = this;

    assertType(type);
    var listeners = this.listeners(type);

    var onceListeners = [];
    if (listeners && listeners.length) {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      for (var i = 0; i < listeners.length; i++) {
        var event = listeners[i];
        var rlt = event.apply(this, args);
        if (isPromise(rlt)) {
          yield rlt;
        }
        if (this._events[type][i][TYPE_KEYNAME] === 'once') {
          onceListeners.push(event);
        }
      }
      onceListeners.forEach(function (event) {
        return _this.removeListener(type, event);
      });

      return true;
    }
    return false;
  });

  return function emit(_x) {
    return _ref3.apply(this, arguments);
  };
}();

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

/**
 * @file: AwaitEventEmitter
 * @author: Cuttle Cong
 * @date: 2017/11/1
 * @description:
 */

var TYPE_KEYNAME = typeof Symbol === 'function' ? Symbol('--[[await-event-emitter]]--') : '--[[await-event-emitter]]--';

function assertType(type) {
  if (typeof type !== 'string' && (typeof type === 'undefined' ? 'undefined' : _typeof(type)) !== 'symbol') {
    throw new TypeError('type is not type of string or symbol!');
  }
}

function assertFn(fn) {
  if (typeof fn !== 'function') {
    throw new TypeError('fn is not type of Function!');
  }
}

function alwaysListener(fn) {
  var _ref;

  return _ref = {}, _ref[TYPE_KEYNAME] = 'always', _ref.fn = fn, _ref;
}
function onceListener(fn) {
  var _ref2;

  return _ref2 = {}, _ref2[TYPE_KEYNAME] = 'once', _ref2.fn = fn, _ref2;
}

function AwaitEventEmitter() {
  this._events = {};
}

function on(type, fn) {
  assertType(type);
  assertFn(fn);
  this._events[type] = this._events[type] || [];
  this._events[type].push(alwaysListener(fn));
  return this;
}

function prepend(type, fn) {
  assertType(type);
  assertFn(fn);
  this._events[type] = this._events[type] || [];
  this._events[type].unshift(alwaysListener(fn));
  return this;
}

function prependOnce(type, fn) {
  assertType(type);
  assertFn(fn);
  this._events[type] = this._events[type] || [];
  this._events[type].unshift(onceListener(fn));
  return this;
}

function listeners(type) {
  return (this._events[type] || []).map(function (x) {
    return x.fn;
  });
}

function once(type, fn) {
  assertType(type);
  assertFn(fn);
  this._events[type] = this._events[type] || [];
  this._events[type].push(onceListener(fn));
  return this;
}

function removeListener(type, nullOrFn) {
  assertType(type);

  var listeners = this.listeners(type);
  if (typeof nullOrFn === 'function') {
    var index = void 0,
        found = false;
    while ((index = listeners.indexOf(nullOrFn)) >= 0) {
      listeners.splice(index, 1);
      this._events[type].splice(index, 1);
      found = true;
    }
    return found;
  } else {
    return delete this._events[type];
  }
}

function emitSync(type) {
  var _this2 = this;

  assertType(type);
  var listeners = this.listeners(type);
  var onceListeners = [];
  if (listeners && listeners.length) {
    for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }

    for (var i = 0; i < listeners.length; i++) {
      var event = listeners[i];
      event.apply(this, args);

      if (this._events[type][i][TYPE_KEYNAME] === 'once') {
        onceListeners.push(event);
      }
    }
    onceListeners.forEach(function (event) {
      return _this2.removeListener(type, event);
    });

    return true;
  }
  return false;
}

AwaitEventEmitter.prototype.on = AwaitEventEmitter.prototype.addListener = on;
AwaitEventEmitter.prototype.once = once;
AwaitEventEmitter.prototype.prependListener = prepend;
AwaitEventEmitter.prototype.prependOnceListener = prependOnce;
AwaitEventEmitter.prototype.off = AwaitEventEmitter.prototype.removeListener = removeListener;
AwaitEventEmitter.prototype.emit = emit;
AwaitEventEmitter.prototype.emitSync = emitSync;
AwaitEventEmitter.prototype.listeners = listeners;

{
  module.exports = AwaitEventEmitter;
}
});

module.exports = nodeAwaitEventEmitter;
